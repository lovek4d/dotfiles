c() {
  if [[ $# -gt 0 ]]; then
    claude "$@"
    return
  fi
  cat <<'EOF'
claude aliases:
  core
    cn     claude (new interactive session)
    cq     claude --print (quick)
    cr     claude --resume
  quick + model
    cqh    claude --print --model haiku
    cqo    claude --print --model opus
    cqs    claude --print --model sonnet
  workflow
    cgt    worktree + tmux + claude
    cgtd   destroy worktree + tmux session
    cup    brew upgrade claude-code
  queue
    cinit  setup ~/.claude/settings.json
    cw     waiting sessions (fzf jump)
    cwc    clear stale queue entries
    cwf    auto-focus mode (cycles waiting sessions)
EOF
}

alias cn='claude'
alias cq='claude --print'
alias cr='claude --resume'
alias cqh='claude --print --model haiku'
alias cqs='claude --print --model sonnet'
alias cqo='claude --print --model opus'
alias cup='brew upgrade claude-code'

cgt() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<'EOF'
cgt — create a worktree + tmux session + launch claude code

usage: cgt [branch-name]

  If branch-name is given, creates (or reuses) that branch.
  If omitted, fzf-selects from existing branches.

  Creates a git worktree, opens a tmux session named after
  the branch, and starts claude code inside it.

  On exit, the worktree is automatically removed (unless dirty).
  Use cgtd to manually tear down a worktree + tmux session.
EOF
    return 0
  fi

  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null)" || { echo "not in a git repo"; return 1; }

  # resolve branch: argument or fzf select
  local branch
  if [[ -n "$1" ]]; then
    branch="$1"
  else
    branch=$(git branch -a --format='%(refname:short)' \
      | fzf --prompt='worktree branch> ' --height=40% --reverse)
    [[ -z "$branch" ]] && return 1
  fi

  local base_dir="$(dirname "$root")/$(basename "$root")-worktrees"
  local target="$base_dir/$branch"

  # create worktree: new branch from HEAD if doesn't exist, else use existing
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$target" "$branch"
  else
    git worktree add -b "$branch" "$target"
  fi
  [[ $? -ne 0 ]] && return 1

  # sanitize branch name for tmux session (replace / with -)
  local session="${branch//\//-}"

  # create tmux session: launch claude, then auto-remove worktree on exit
  local cmd="claude; cd '${root}' && git worktree remove '${target}'"

  if [[ -n "$TMUX" ]]; then
    tmux new-session -ds "$session" -c "$target" "$cmd"
    tmux switch-client -t "$session"
  else
    tmux new-session -s "$session" -c "$target" "$cmd"
  fi
}

cgtd() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<'EOF'
cgtd — destroy a worktree + tmux session

usage: cgtd

  fzf-selects from active worktrees (excluding the main one),
  kills the associated tmux session, and removes the worktree.

  The branch itself is left intact.

  Inverse of cgt.
EOF
    return 0
  fi

  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null)" || { echo "not in a git repo"; return 1; }

  local selection
  selection=$(git worktree list | tail -n +2 \
    | fzf --prompt='destroy worktree> ' --height=40% --reverse)
  [[ -z "$selection" ]] && return 1

  local wt_path branch session
  wt_path=$(echo "$selection" | awk '{print $1}')
  branch=$(echo "$selection" | awk '{print $3}' | tr -d '[]')
  session="${branch//\//-}"

  tmux kill-session -t "$session" 2>/dev/null
  git worktree remove "$wt_path"

  echo "destroyed worktree: $branch ($wt_path)"
}

cinit() {
  mkdir -p ~/.claude/queue
  python3 -c '
import json, os
path = os.path.expanduser("~/.claude/settings.json")
settings = {}
if os.path.exists(path):
    with open(path) as f:
        settings = json.load(f)

enqueue = (
    "bash -c '\''D=$HOME/.claude/queue; mkdir -p \"$D\"; "
    "S=$(tmux display-message -p \"#{session_name}\" 2>/dev/null) || exit 0; "
    "[ -f \"$D/$S\" ] && exit 0; touch \"$D/$S\"; "
    "printf \"\\a\"; tmux display-message \"Claude waiting: $S\" 2>/dev/null; exit 0'\''"
)
dequeue = (
    "bash -c '\''S=$(tmux display-message -p \"#{session_name}\" 2>/dev/null) || exit 0; "
    "rm -f \"$HOME/.claude/queue/$S\"; exit 0'\''"
)

settings["hooks"] = {
    "Notification": [{"matcher": "idle_prompt|permission_prompt",
        "hooks": [{"type": "command", "command": enqueue, "timeout": 5}]}],
    "Stop": [{"hooks": [{"type": "command", "command": enqueue, "timeout": 5}]}],
    "UserPromptSubmit": [{"hooks": [{"type": "command", "command": dequeue, "timeout": 5}]}],
    "SessionEnd": [{"hooks": [{"type": "command", "command": dequeue, "timeout": 5}]}],
}

with open(path, "w") as f:
    json.dump(settings, f, indent=2)
  '
  echo "claude settings.json updated with queue hooks"
}

cw() {
  local queue_dir="$HOME/.claude/queue"
  [[ ! -d "$queue_dir" ]] && echo "no queue directory (run cinit)" && return 1

  # prune stale entries
  local waiting=()
  for f in "$queue_dir"/*(.N); do
    local session="${f:t}"
    if tmux has-session -t "$session" 2>/dev/null; then
      waiting+=("$session")
    else
      rm -f "$f"
    fi
  done

  if [[ ${#waiting[@]} -eq 0 ]]; then
    echo "no sessions waiting"
    return 0
  fi

  echo "${#waiting[@]} session(s) waiting"

  if [[ -n "$TMUX" ]]; then
    local choice
    choice=$(printf '%s\n' "${waiting[@]}" \
      | fzf --prompt='jump to> ' --height=40% --reverse)
    [[ -n "$choice" ]] && tmux switch-client -t "$choice"
  else
    printf '  %s\n' "${waiting[@]}"
  fi
}

cwc() {
  local queue_dir="$HOME/.claude/queue"
  [[ ! -d "$queue_dir" ]] && return 0

  local count=0
  for f in "$queue_dir"/*(.N); do
    local session="${f:t}"
    if ! tmux has-session -t "$session" 2>/dev/null; then
      rm -f "$f"
      ((count++))
    fi
  done
  echo "cleared $count stale queue entry(s)"
}

cwf() {
  local queue_dir="$HOME/.claude/queue"
  [[ ! -d "$queue_dir" ]] && echo "no queue directory (run cinit)" && return 1
  [[ -z "$TMUX" ]] && echo "cwf must be run inside a tmux session" && return 1

  echo "auto-focus mode (ctrl-c to stop)"
  while true; do
    # find next waiting session
    local next=""
    for f in "$queue_dir"/*(.N); do
      local session="${f:t}"
      if tmux has-session -t "$session" 2>/dev/null; then
        next="$session"
        break
      else
        rm -f "$f"
      fi
    done

    if [[ -z "$next" ]]; then
      sleep 2
      continue
    fi

    tmux switch-client -t "$next"
    echo "switched to: $next"

    # wait until this session's queue file disappears (user answered)
    while [[ -f "$queue_dir/$next" ]]; do
      sleep 1
    done
  done
}
