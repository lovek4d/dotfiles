c() {
  if [[ $# -gt 0 ]]; then
    claude "$@"
    return
  fi
  cat <<'EOF'
claude aliases:
  core
    cn     claude (new interactive session)
    cq     claude --print (quick)
    cr     claude --resume
  quick + model
    cqh    claude --print --model haiku
    cqo    claude --print --model opus
    cqs    claude --print --model sonnet
  workflow
    cgt    worktree + tmux + claude
    cgtd   destroy worktree + tmux session
    cup    brew upgrade claude-code
EOF
}

alias cn='claude'
alias cq='claude --print'
alias cr='claude --resume'
alias cqh='claude --print --model haiku'
alias cqs='claude --print --model sonnet'
alias cqo='claude --print --model opus'
alias cup='brew upgrade claude-code'

cgt() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<'EOF'
cgt — create a worktree + tmux session + launch claude code

usage: cgt [branch-name]

  If branch-name is given, creates (or reuses) that branch.
  If omitted, fzf-selects from existing branches.

  Creates a git worktree, opens a tmux session named after
  the branch, and starts claude code inside it.

  Use cgtd to tear down a worktree + tmux session.
EOF
    return 0
  fi

  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null)" || { echo "not in a git repo"; return 1; }

  # resolve branch: argument or fzf select
  local branch
  if [[ -n "$1" ]]; then
    branch="$1"
  else
    branch=$(git branch -a --format='%(refname:short)' \
      | fzf --prompt='worktree branch> ' --height=40% --reverse)
    [[ -z "$branch" ]] && return 1
  fi

  local base_dir="$(dirname "$root")/$(basename "$root")-worktrees"
  local target="$base_dir/$branch"

  # create worktree: new branch from HEAD if doesn't exist, else use existing
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$target" "$branch"
  else
    git worktree add -b "$branch" "$target"
  fi
  [[ $? -ne 0 ]] && return 1

  # sanitize branch name for tmux session (replace / with -)
  local session="${branch//\//-}"

  # create tmux session and launch claude
  if [[ -n "$TMUX" ]]; then
    tmux new-session -ds "$session" -c "$target" "claude"
    tmux switch-client -t "$session"
  else
    tmux new-session -s "$session" -c "$target" "claude"
  fi
}

cgtd() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<'EOF'
cgtd — destroy a worktree + tmux session

usage: cgtd

  fzf-selects from active worktrees (excluding the main one),
  kills the associated tmux session, and removes the worktree.

  The branch itself is left intact.

  Inverse of cgt.
EOF
    return 0
  fi

  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null)" || { echo "not in a git repo"; return 1; }

  local selection
  selection=$(git worktree list | tail -n +2 \
    | fzf --prompt='destroy worktree> ' --height=40% --reverse)
  [[ -z "$selection" ]] && return 1

  local wt_path branch session
  wt_path=$(echo "$selection" | awk '{print $1}')
  branch=$(echo "$selection" | awk '{print $3}' | tr -d '[]')
  session="${branch//\//-}"

  tmux kill-session -t "$session" 2>/dev/null
  git worktree remove "$wt_path"

  echo "destroyed worktree: $branch ($wt_path)"
}
