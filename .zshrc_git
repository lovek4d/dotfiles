# helpers
__git_default_branch() {
  local b
  b="$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | cut -d/ -f2)"
  [[ -z "$b" ]] && b="$(git branch --list main master | head -1 | tr -d ' *')"
  echo "${b:-main}"
}

# core
g() {
  if [[ $# -gt 0 ]]; then
    git "$@"
    return
  fi
  cat <<'EOF'
git aliases:
  core
    ga     git add
    gaa    git add .
    gst    git status
    gpl    git pull --ff-only
    gps    git push
    gfal   git fetch --all --prune
  log
    gl     git log
    glo    git log --oneline
    glg    git log --graph
    glp    git log -p <n>
    glfs   git log -S <str>
    glff   git log --all-match <file>
  stash
    gs     git stash
    gsp    git stash pop
    gsd    git stash drop
    gsm    git stash -m
    gsl    git stash list
    gsa    git stash apply
    gss    git stash show -p
    gspf   stash pop (fzf)
    gsdf   stash drop (fzf)
  commits
    gc     git commit
    gcm    git commit -m
    gca    git commit --amend
    gcan   amend --no-edit
  merging
    gm     git merge
    gms    merge --squash
    gmn    merge --no-edit
    gmo    merge -X ours
    gmt    merge -X theirs
    gmon   -X ours --no-edit
    gmtn   -X theirs --no-edit
    gcp    git cherry-pick
    grb    git rebase
    gum    merge upstream main
  resets
    grh    git reset --hard
    grs    git reset --soft
    gdc    copy diff to clipboard
  branches
    gbr    git branch
    gco    git checkout
    gswc   git switch --create
    gsw    switch branch (fzf)
    gswm   switch to main
    gswap  swap w/ stash (fzf)
    gdl    delete branch (fzf)
    gpla   pull all repos in cwd
  worktrees
    gwl    git worktree list
    gwp    git worktree prune
    gwa    add worktree (fzf)
    gws    cd to worktree (fzf)
    gwd    rm worktree (fzf)
EOF
}
alias ga='git add'
alias gaa='git add .'
alias gst='git status'
alias gpl='git pull --ff-only'
alias gps='git push'
alias gfal='git fetch --all --prune'

# log
alias gl='git log'
alias glo='git log --oneline'
alias glg='git log --graph'
alias glp='git log -p' # pass number of commits
alias glfs='git log -S' # pass string
alias glff='git log --all-match' # pass filename

# stash
alias gs='git stash'
alias gsp='git stash pop'
alias gsd='git stash drop'
alias gsm='git stash -m'
alias gsl='git stash list'
alias gsa='git stash apply'
alias gss='git stash show -p'

## stash pop (fzf select)
gspf() {
  local entry
  entry=$(git stash list \
    | fzf --prompt='pop stash> ' --height=40% --reverse)
  [[ -z "$entry" ]] && return 1
  git stash pop "${entry%%:*}"
}

## stash drop (fzf select)
gsdf() {
  local entry
  entry=$(git stash list \
    | fzf --prompt='drop stash> ' --height=40% --reverse)
  [[ -z "$entry" ]] && return 1
  git stash drop "${entry%%:*}"
}

# commits
alias gc='git commit'
alias gcm='git commit -m'
alias gca='git commit --amend'
alias gcan='git commit --amend --no-edit'

# merging
alias gm='git merge'
alias gms='git merge --squash'
alias gmn='git merge --no-edit'
alias gmo='git merge -X ours'
alias gmt='git merge -X theirs'
alias gmon='git merge -X ours --no-edit'
alias gmtn='git merge -X theirs --no-edit'
alias gcp='git cherry-pick'
alias grb='git rebase'

## merge upstream (auto-detect main/master)
gum() {
  local base="$(__git_default_branch)"
  git fetch origin "$base" && git merge "origin/$base" --no-edit
}

# resets
alias grh='git reset --hard'
alias grs='git reset --soft'

# copy diff (mac-centric)
alias gdc='git diff | pbcopy && echo "Copied diff to clipboard"'

# branches
alias gbr='git branch'
alias gco='git checkout'
alias gswc='git switch --create'

## switch branch (inline or fzf select)
gsw() {
  if [[ -n "$1" ]]; then
    git switch "$1"
  else
    local branch
    branch=$(git branch --all --format='%(refname:short)' \
      | sed 's#^remotes/##' \
      | sort -u \
      | fzf --prompt='switch> ' --height=40% --reverse)
    [[ -n "$branch" ]] && git switch "$branch"
  fi
}

## switch to main/master (autodetect)
gswm() {
  git switch "$(__git_default_branch)"
}

## swap branch with stash (fzf select)
gswap() {
  local branch
  branch=$(git branch --format='%(refname:short)' \
    | fzf --prompt='swap to> ' --height=40% --reverse)
  [[ -z "$branch" ]] && return 1
  git stash -m "switch staging" && git switch "$branch" && git stash pop
}

## delete branches by pattern, or fzf select
gdl() {
  if [ -n "$1" ]; then
    git branch | grep -E "$1" | sed 's/^\*//' | xargs -n1 git branch -D
  else
    local branches
    branches=$(git branch --format='%(refname:short)' \
      | fzf --multi --prompt='delete branch> ' --height=40% --reverse)
    [[ -z "$branches" ]] && return 1
    echo "$branches" | xargs -n1 git branch -D
  fi
}

# pull all git repos in current dir
gpla() {
  for dir in */; do
    [ -d "$dir/.git" ] || continue
    echo "=== Pulling $dir ==="
    git -C "$dir" pull --ff-only
  done
}

# worktrees
alias gwl='git worktree list'
alias gwp='git worktree prune'

## add worktree for existing branch (fzf select)
gwa() {
  local branch
  branch=$(git branch --format='%(refname:short)' \
    | fzf --prompt='worktree branch> ' --height=40% --reverse)
  [[ -z "$branch" ]] && return 1
  local root
  root="$(git rev-parse --show-toplevel)"
  local base_dir
  base_dir="$(dirname "$root")/$(basename "$root")-worktrees"
  local target="$base_dir/$branch"
  mkdir -p "$(dirname "$target")"
  git worktree add "$target" "$branch"
  echo "Worktree at: $target"
}

## cd to worktree (fzf select)
gws() {
  local selected
  selected=$(git worktree list --porcelain \
    | grep '^worktree ' \
    | sed 's/^worktree //' \
    | fzf --prompt='worktree> ' --height=40% --reverse)
  [[ -n "$selected" ]] && cd "$selected"
}

## remove worktree (fzf select)
gwd() {
  local selected
  selected=$(git worktree list \
    | fzf --prompt='remove worktree> ' --height=40% --reverse \
    | awk '{print $1}')
  [[ -n "$selected" ]] && git worktree remove "$selected"
}

# completions
compdef _git gsw=git-switch
